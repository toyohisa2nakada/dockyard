<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>Snake + Tetris</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background: #111;
            color: white;
            margin: 0;
            padding: 20px;
        }

        .game-container {
            display: flex;
            justify-content: center;
            gap: 40px;
        }

        canvas {
            background: #111;
            border: 2px solid #0f0;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }

        .score {
            font-size: 18px;
            margin: 5px;
            text-shadow: 0 0 5px #0f0;
        }

        #restart-btn {
            margin-top: 10px;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            background-color: #0f0;
            color: #111;
            box-shadow: 0 0 10px #0f0;
        }

        #restart-btn:hover {
            background-color: #0c0;
        }
    </style>
</head>

<body>

    <div class="game-container">
        <div>
            <p class="score" id="scoreSnake">Snake Points: 0</p>
            <canvas id="canvasSnake" width="400" height="400"></canvas>
        </div>
        <div>
            <p class="score" id="scoreTetris">Tetris Points: 0</p>
            <canvas id="canvasTetris" width="200" height="400"></canvas>
        </div>
    </div>
    <button id="restart-btn">Restart</button>

    <script>
        // -------- 左边贪吃蛇 --------
        const gridSize = 20;
        const snakeCanvas = document.getElementById('canvasSnake');
        const snakeCtx = snakeCanvas.getContext('2d');
        const scoreSnakeDisplay = document.getElementById('scoreSnake');

        let snake = [{ x: 8 * gridSize, y: 8 * gridSize }];
        let direction = { x: 0, y: 0 };
        let food = generateFood();
        let snakeScore = 0;
        let snakeInterval = null;
        const snakeSpeed = 150;

        let tetrisStarted = false; // ✅ 标志：是否已启动俄罗斯方块

        function generateFood() {
            return {
                x: Math.floor(Math.random() * 20) * gridSize,
                y: Math.floor(Math.random() * 20) * gridSize
            };
        }

        function drawSnake() {
            snakeCtx.clearRect(0, 0, 400, 400);
            snakeCtx.strokeStyle = "rgba(0,255,0,0.1)";
            for (let i = 0; i <= 20; i++) {
                snakeCtx.beginPath();
                snakeCtx.moveTo(i * gridSize, 0);
                snakeCtx.lineTo(i * gridSize, 400);
                snakeCtx.stroke();
                snakeCtx.beginPath();
                snakeCtx.moveTo(0, i * gridSize);
                snakeCtx.lineTo(400, i * gridSize);
                snakeCtx.stroke();
            }
            // 食物
            snakeCtx.fillStyle = '#ff0000';
            snakeCtx.shadowBlur = 15;
            snakeCtx.shadowColor = '#ff0000';
            snakeCtx.fillRect(food.x, food.y, gridSize, gridSize);
            snakeCtx.shadowBlur = 0;
            // 蛇发光
            snake.forEach((seg, i) => {
                const depth = i / snake.length;
                const color = `hsl(${120 - depth * 50},100%,${50 - depth * 20}%)`;
                snakeCtx.fillStyle = color;
                snakeCtx.shadowBlur = 10;
                snakeCtx.shadowColor = color;
                snakeCtx.fillRect(seg.x, seg.y, gridSize, gridSize);
            });
            snakeCtx.shadowBlur = 0;
        }

        function moveSnake() {
            const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };
            snake.unshift(head);
            if (head.x === food.x && head.y === food.y) {
                food = generateFood();
                snakeScore++;
                scoreSnakeDisplay.textContent = "Snake Points: " + snakeScore;
            } else {
                snake.pop();
            }
            // 碰撞检测
            if (head.x < 0 || head.x >= 400 || head.y < 0 || head.y >= 400) {
                clearInterval(snakeInterval);
                alert("Snake Game Over!");
            }
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    clearInterval(snakeInterval);
                    alert("Snake Game Over!");
                }
            }
            drawSnake();
        }

        document.addEventListener('keydown', e => {
            if (e.key === 'w' && direction.y !== gridSize) direction = { x: 0, y: -gridSize };
            else if (e.key === 's' && direction.y !== -gridSize) direction = { x: 0, y: gridSize };
            else if (e.key === 'a' && direction.x !== gridSize) direction = { x: -gridSize, y: 0 };
            else if (e.key === 'd' && direction.x !== -gridSize) direction = { x: gridSize, y: 0 };

            // ✅ 第一次按下方向键时启动俄罗斯方块
            if (!tetrisStarted && (['w', 'a', 's', 'd'].includes(e.key))) {
                tetrisStarted = true;
                startTetris();
            }
        });

        function startSnake() {
            if (snakeInterval) clearInterval(snakeInterval);
            snakeInterval = setInterval(moveSnake, snakeSpeed);
        }

        // -------- 右边俄罗斯方块 --------
        const tCanvas = document.getElementById('canvasTetris');
        const tCtx = tCanvas.getContext('2d');
        const scoreTetrisDisplay = document.getElementById('scoreTetris');

        const tCols = 10, tRows = 20, tSize = 20;
        let tBoard = Array.from({ length: tRows }, () => Array(tCols).fill(0));
        let tScore = 0;
        let tInterval = null;
        let currentPiece = null;
        let tetrisActive = false;

        const pieces = [
            { color: 'cyan', shape: [[1, 1, 1, 1]] },
            { color: 'blue', shape: [[1, 0, 0], [1, 1, 1]] },
            { color: 'orange', shape: [[0, 0, 1], [1, 1, 1]] },
            { color: 'yellow', shape: [[1, 1], [1, 1]] },
            { color: 'green', shape: [[0, 1, 1], [1, 1, 0]] },
            { color: 'purple', shape: [[0, 1, 0], [1, 1, 1]] },
            { color: 'red', shape: [[1, 1, 0], [0, 1, 1]] }
        ];

        function newPiece() {
            const p = pieces[Math.floor(Math.random() * pieces.length)];
            return { x: 3, y: 0, shape: p.shape, color: p.color };
        }

        function drawTetris() {
            tCtx.clearRect(0, 0, 200, 400);
            for (let r = 0; r < tRows; r++) {
                for (let c = 0; c < tCols; c++) {
                    if (tBoard[r][c]) {
                        tCtx.fillStyle = tBoard[r][c];
                        tCtx.shadowBlur = 10;
                        tCtx.shadowColor = tBoard[r][c];
                        tCtx.fillRect(c * tSize, r * tSize, tSize, tSize);
                    }
                }
            }
            if (currentPiece) {
                currentPiece.shape.forEach((row, i) => {
                    row.forEach((val, j) => {
                        if (val) {
                            tCtx.fillStyle = currentPiece.color;
                            tCtx.shadowBlur = 10;
                            tCtx.shadowColor = currentPiece.color;
                            tCtx.fillRect((currentPiece.x + j) * tSize, (currentPiece.y + i) * tSize, tSize, tSize);
                        }
                    });
                });
            }
            tCtx.shadowBlur = 0;
        }

        function collide(xOffset = 0, yOffset = 0, p = currentPiece) {
            for (let r = 0; r < p.shape.length; r++) {
                for (let c = 0; c < p.shape[r].length; c++) {
                    if (p.shape[r][c]) {
                        const x = p.x + c + xOffset;
                        const y = p.y + r + yOffset;
                        if (y >= tRows || x < 0 || x >= tCols || (y >= 0 && tBoard[y][x])) return true;
                    }
                }
            }
            return false;
        }

        function mergePiece() {
            currentPiece.shape.forEach((row, r) => {
                row.forEach((val, c) => {
                    if (val) {
                        tBoard[currentPiece.y + r][currentPiece.x + c] = currentPiece.color;
                    }
                });
            });
        }

        function clearLines() {
            let linesCleared = 0;
            for (let r = tRows - 1; r >= 0; r--) {
                if (tBoard[r].every(cell => cell)) {
                    tBoard.splice(r, 1);
                    tBoard.unshift(Array(tCols).fill(0));
                    linesCleared++;
                    r++;
                }
            }
            if (linesCleared > 0) {
                tScore += linesCleared;
                scoreTetrisDisplay.textContent = "Tetris Points: " + tScore;
                // 奖励蛇
                for (let i = 0; i < linesCleared; i++) {
                    snake.push({ x: snake[snake.length - 1].x, y: snake[snake.length - 1].y });
                }
            }
        }

        function movePieceDown() {
            if (!collide(0, 1)) currentPiece.y++;
            else {
                mergePiece();
                clearLines();
                currentPiece = newPiece();
                if (collide(0, 0)) {
                    clearInterval(tInterval);
                    alert("Tetris Game Over!");
                    tetrisActive = false;
                }
            }
            drawTetris();
        }

        function movePieceLR(dir) {
            if (!collide(dir, 0)) currentPiece.x += dir;
            drawTetris();
        }

        function rotatePiece() {
            const shape = currentPiece.shape;
            const newShape = shape[0].map((_, i) => shape.map(row => row[i])).reverse();
            const oldShape = currentPiece.shape;
            currentPiece.shape = newShape;
            if (collide(0, 0)) currentPiece.shape = oldShape;
            drawTetris();
        }

        document.addEventListener('keydown', e => {
            if (!tetrisActive) return;
            if (e.key === 'ArrowLeft') movePieceLR(-1);
            else if (e.key === 'ArrowRight') movePieceLR(1);
            else if (e.key === 'ArrowDown') movePieceDown();
            else if (e.key === 'ArrowUp') rotatePiece();
        });

        function startTetris() {
            if (!currentPiece) currentPiece = newPiece();
            if (tInterval) clearInterval(tInterval);
            tInterval = setInterval(movePieceDown, 500);
            tetrisActive = true;
        }

        // -------- Restart 按钮 --------
        document.getElementById('restart-btn').addEventListener('click', () => {
            snake = [{ x: 8 * gridSize, y: 8 * gridSize }];
            direction = { x: 0, y: 0 };
            food = generateFood();
            snakeScore = 0;
            scoreSnakeDisplay.textContent = "Snake Points: 0";
            if (snakeInterval) clearInterval(snakeInterval);
            startSnake();

            tBoard = Array.from({ length: tRows }, () => Array(tCols).fill(0));
            tScore = 0;
            scoreTetrisDisplay.textContent = "Tetris Points: 0";
            currentPiece = null;
            if (tInterval) clearInterval(tInterval);
            tetrisActive = false;
            tetrisStarted = false;
            drawTetris();
        });

        startSnake();
        drawTetris();
    </script>
</body>

</html>